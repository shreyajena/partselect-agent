# PartSelect Chat Agent - Backend

FastAPI-based backend for the PartSelect chat agent, featuring intent-based routing, RAG (Retrieval Augmented Generation), and DeepSeek LLM integration.

## ğŸ“‹ Table of Contents

- [Overview](#overview)
- [Data Sources](#data-sources)
- [Architecture](#architecture)
- [Architecture Decisions](#architecture-decisions)
- [Setup](#setup)
- [API Documentation](#api-documentation)
- [Intent System](#intent-system)
- [Data Models](#data-models)
- [Testing](#testing)
- [Deployment](#deployment)

## ğŸ¯ Overview

The backend is built with **FastAPI** and provides:
- **Intent-based routing** for 8 distinct user intents
- **RAG implementation** using ChromaDB for semantic search
- **DeepSeek LLM integration** (required by case study)
- **SQLite database** for structured data (parts, models, orders)
- **Modular architecture** for easy extensibility

## ğŸ“Š Data Sources

### Current State (Demo/Development)
- **Parts & Models**: Web-scraped CSV files in `data/` directory (via `backend/scrappers/`)
- **Repair Guides & Blogs**: Web-scraped JSON files in `data/` directory
- **Orders**: Dummy data generated by `scripts/seed_orders.py` for testing order support features

### Production API Integration
The backend is designed with a **production-ready API abstraction layer**:

**API Client Architecture:**
- `app/data/api_client.py` contains `PartSelectAPIClient` class
- Currently reads from local files (stub implementation)
- Methods mirror real API endpoints:
  - `fetch_part_records()` - Parts metadata
  - `fetch_crossref_records()` - Part-to-model mappings
  - `fetch_blog_documents()` - Blog articles
  - `fetch_repair_guides()` - Repair guides

**Seamless Transition:**
- `scripts/ingest_from_api.py` uses the API client for ingestion
- When PartSelect APIs are available, simply update `PartSelectAPIClient` to make HTTP requests
- **No changes needed** to ingestion scripts, handlers, or database models
- The entire pipeline works identically with API or file-based data

This architecture allows immediate functionality with scraped data while ensuring easy migration to production APIs.

## ğŸ—ï¸ Architecture

### Directory Structure

```
backend/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ agent/              # Business logic handlers
â”‚   â”‚   â”œâ”€â”€ chat_agent.py   # Main entry point
â”‚   â”‚   â”œâ”€â”€ handlers.py     # Intent handlers
â”‚   â”‚   â”œâ”€â”€ db_queries.py   # Database query helpers
â”‚   â”‚   â””â”€â”€ utils.py        # Utility functions
â”‚   â”‚
â”‚   â”œâ”€â”€ router/             # Intent routing
â”‚   â”‚   â”œâ”€â”€ router.py       # Main routing logic
â”‚   â”‚   â”œâ”€â”€ intents.py      # Intent definitions
â”‚   â”‚   â”œâ”€â”€ keywords.py     # Keyword lists
â”‚   â”‚   â””â”€â”€ extractors.py   # Metadata extraction
â”‚   â”‚
â”‚   â”œâ”€â”€ config/             # Configuration
â”‚   â”‚   â”œâ”€â”€ constants.py    # Constants
â”‚   â”‚   â”œâ”€â”€ prompts.py      # LLM prompts
â”‚   â”‚   â””â”€â”€ urls.py         # URL constants
â”‚   â”‚
â”‚   â”œâ”€â”€ llm/                # LLM clients
â”‚   â”‚   â”œâ”€â”€ client.py       # Provider selector
â”‚   â”‚   â”œâ”€â”€ deepseek.py     # DeepSeek client
â”‚   â”‚   â””â”€â”€ openai_client.py # OpenAI client (fallback)
â”‚   â”‚
â”‚   â”œâ”€â”€ rag/                # RAG implementation
â”‚   â”‚   â”œâ”€â”€ retrieval.py    # Document retrieval
â”‚   â”‚   â”œâ”€â”€ rag_query.py    # Collection queries
â”‚   â”‚   â”œâ”€â”€ rag_store.py    # ChromaDB store
â”‚   â”‚   â””â”€â”€ rag_ingest.py   # Data ingestion
â”‚   â”‚
â”‚   â”œâ”€â”€ models.py           # SQLAlchemy models
â”‚   â”œâ”€â”€ db.py               # Database setup
â”‚   â”œâ”€â”€ config.py           # Settings
â”‚   â””â”€â”€ main.py             # FastAPI app
â”‚
â”œâ”€â”€ data/                   # Seed data
â”‚   â”œâ”€â”€ dishwasher_parts.csv
â”‚   â”œâ”€â”€ refrigerator_parts.csv
â”‚   â”œâ”€â”€ repair_guides.json
â”‚   â””â”€â”€ blogs.json
â”‚
â”œâ”€â”€ scripts/                # Data ingestion
â”‚   â”œâ”€â”€ ingest_parts.py
â”‚   â””â”€â”€ ingest_docs.py
â”‚
â”œâ”€â”€ tests/                  # Test suite
â”‚   â”œâ”€â”€ unit/
â”‚   â””â”€â”€ integration/
â”‚
â””â”€â”€ requirements.txt
```

### Request Flow

```
User Message
    â”‚
    â–¼
route_intent() â”€â”€â–º Extract metadata (part ID, model, order ID, etc.)
    â”‚
    â–¼
RouteDecision â”€â”€â–º Intent + Metadata
    â”‚
    â–¼
handle_message() â”€â”€â–º Dispatch to handler
    â”‚
    â”œâ”€â”€â–º handle_product_info() â”€â”€â–º SQL query + LLM
    â”œâ”€â”€â–º handle_compat_check() â”€â”€â–º SQL query only
    â”œâ”€â”€â–º handle_repair_help() â”€â”€â–º RAG + LLM
    â”œâ”€â”€â–º handle_blog_howto() â”€â”€â–º RAG + LLM
    â”œâ”€â”€â–º handle_order_support() â”€â”€â–º SQL query + LLM
    â””â”€â”€â–º ...
    â”‚
    â–¼
Response: {reply, metadata}
```

## ğŸ›ï¸ Architecture Decisions

### 1. Intent-Based Routing (Not LLM-Based)
**Decision**: Use keyword + regex-based routing instead of LLM for intent classification.

**Rationale**:
- **Speed**: Sub-millisecond routing vs. 500ms+ LLM calls
- **Cost**: Zero routing cost vs. $0.001+ per request
- **Determinism**: Consistent routing, easier debugging
- **Reliability**: Works even if LLM is down

**Implementation**: 
- Keyword lists in `app/router/keywords.py`
- Regex extractors in `app/router/extractors.py`
- Priority-based routing logic in `app/router/router.py`

### 2. Hybrid Approach: Rules + LLM
**Decision**: Combine deterministic routing with LLM for natural language responses.

**Rationale**:
- **Best of Both Worlds**: Fast routing + natural responses
- **Accuracy**: Rules ensure correct intent, LLM provides context
- **Flexibility**: LLM adapts to user phrasing while routing stays consistent

**Implementation**:
- Routing: Keyword matching + metadata extraction
- Responses: LLM with structured context (SQL data or RAG documents)

### 3. Rich Metadata Responses
**Decision**: Return structured metadata (product cards, order cards) alongside text responses.

**Rationale**:
- **Better UX**: Visual cards vs. text-only responses
- **Reduced LLM Verbosity**: Metadata handles structured info, LLM focuses on explanation
- **Actionable**: Direct links and buttons for user actions
- **Consistency**: Standardized UI components

**Implementation**:
- Handlers return `{reply, metadata}` structure
- Frontend renders `ProductCard`, `OrderCard`, `LinkButtons` based on metadata type

### 4. RAG with Dual Collections + MMR
**Decision**: Separate collections (repairs/blogs) with Maximal Marginal Relevance ranking.

**Rationale**:
- **Source Control**: Different collections for different content types
- **Diversity**: MMR prevents redundant results
- **Quality**: Source bias ensures preferred collection results
- **Flexibility**: Easy to add new collections

**Implementation**:
- ChromaDB collections: `repairs` and `blogs`
- MMR ranking with Î»=0.7 (balance relevance vs. diversity)
- Source bias (0.1) for preferred collection
- Keyword bonus (0.2) for exact matches

### 5. Modular Architecture
**Decision**: Separate concerns into distinct modules (router, handlers, queries, utils, config).

**Rationale**:
- **Maintainability**: Clear boundaries, easy to locate code
- **Testability**: Isolated units, comprehensive test coverage
- **Extensibility**: Add features without touching existing code
- **Scalability**: Easy to optimize individual components

**Implementation**:
```
app/
â”œâ”€â”€ router/     # Intent classification + extraction
â”œâ”€â”€ agent/       # Business logic handlers
â”œâ”€â”€ config/      # Constants, prompts, URLs
â”œâ”€â”€ llm/         # LLM client abstraction
â””â”€â”€ rag/         # Vector DB + retrieval
```

### 6. Metadata Extraction Strategy
**Decision**: Regex-based extraction for structured data (part IDs, model numbers, order IDs).

**Rationale**:
- **Fast**: No API calls needed
- **Reliable**: Handles variations (PS123456, PS-123456, part PS123456)
- **Comprehensive**: Multiple patterns per entity type
- **Maintainable**: Centralized in `extractors.py`

**Implementation**:
- Part ID: `PS\d{6,8}` pattern with variations
- Model Number: Brand-specific patterns
- Order ID: Multiple formats (`order #4`, `orderid #3`, `order number is #4`)

### 7. Retry Logic with Exponential Backoff
**Decision**: Implement retry logic for LLM calls with exponential backoff.

**Rationale**:
- **Reliability**: Handles transient API failures
- **Efficiency**: Exponential backoff prevents API overload
- **User Experience**: Automatic recovery, transparent to user

**Implementation**:
- Max retries: 3 attempts
- Backoff: `base^attempt` seconds (1s, 2s, 4s)
- Fallback: Error message if all retries fail

### 8. Extensibility Patterns
**Decision**: Design for easy extension without code changes to core logic.

**Rationale**:
- **Future-Proof**: Easy to add new intents, handlers, collections
- **Maintainable**: Changes isolated to specific modules
- **Scalable**: Can grow without refactoring

**How to Extend**:
- **New Intent**: Add to `Intent` enum â†’ Add keywords â†’ Create handler â†’ Add dispatch
- **New RAG Collection**: Add collection â†’ Update `DEFAULT_COLLECTIONS` â†’ Create handler
- **New LLM Provider**: Add client in `llm/` â†’ Update `get_chat_client()`

## ğŸš€ Setup

### 1. Install Dependencies

```bash
cd backend
python3 -m venv .venv
source .venv/bin/activate  # On Windows: .venv\Scripts\activate
pip install -r requirements.txt
```

### 2. Configure Environment

Create `.env` file:

```bash
INSTALILY_DEEPSEEK_API_KEY=your_key_here
INSTALILY_LLM_PROVIDER=deepseek
INSTALILY_DEEPSEEK_MODEL=deepseek-chat
INSTALILY_LOG_LEVEL=INFO
```

### 3. Ingest Data

**Parts and Models:**
   ```bash
   python -m scripts.ingest_parts
   ```
This loads:
- `data/dishwasher_parts.csv` â†’ `parts` table
- `data/refrigerator_parts.csv` â†’ `parts` table
- `data/dishwasher_parts_crossref.csv` â†’ `models` + `part_model_mapping`
- `data/refrigerator_parts_crossref.csv` â†’ `models` + `part_model_mapping`

**Vector Store (RAG):**
   ```bash
   python -m scripts.ingest_docs
   ```
This indexes:
- `data/repair_guides.json` â†’ `repairs` collection
- `data/blogs.json` â†’ `blogs` collection

### 4. Seed Demo Orders (Optional)

```bash
python -m scripts.seed_orders
```

### 5. Run Server

```bash
uvicorn app.main:app --reload
```

Server runs at: `http://localhost:8000`

## ğŸ“¡ API Documentation

### Endpoints

#### `POST /chat`

Main chat endpoint.

**Request:**
```json
{
  "message": "How do I install PS11752778?",
  "conversation_snippet": null
}
```

**Response:**
```json
{
  "reply": "PS11752778 is a Water Inlet Valve...",
  "metadata": {
    "type": "product_info",
    "product": {
      "id": "PS11752778",
      "name": "Water Inlet Valve",
      "price": 45.99,
      "url": "https://www.partselect.com/...",
      ...
    }
  }
}
```

#### `GET /health`

Health check endpoint.

**Response:**
```json
{
  "status": "ok"
}
```

#### `GET /`

Service info.

**Response:**
```json
{
  "service": "PartSelect Chat Agent",
  "status": "online",
  "version": "0.1.0"
}
```

### Interactive API Docs

Visit `http://localhost:8000/docs` for Swagger UI.

## ğŸ§  Intent System

The backend supports 8 distinct intents:

| Intent | Description | Example |
|--------|-------------|---------|
| `PRODUCT_INFO` | Part information | "Tell me about PS11752778" |
| `COMPAT_CHECK` | Compatibility check | "Is PS11752778 compatible with WDT780SAEM1?" |
| `REPAIR_HELP` | Repair guidance | "My dishwasher is leaking" |
| `BLOG_HOWTO` | Usage/how-to questions | "What is eco mode?" |
| `ORDER_SUPPORT` | Order tracking/returns | "Where is order #4?" |
| `POLICY` | Policy questions | "What's your return policy?" |
| `OUT_OF_SCOPE` | Out of scope queries | "Tell me about microwaves" |
| `CLARIFICATION` | Needs more info | "Check compatibility" (missing model) |

### Routing Logic

1. **Metadata Extraction**: Extract part IDs, model numbers, order IDs, etc.
2. **Keyword Matching**: Match against keyword lists
3. **Intent Classification**: Determine intent based on keywords + metadata
4. **Handler Dispatch**: Route to appropriate handler

### Adding New Intents

1. Add to `Intent` enum in `app/router/intents.py`
2. Add keywords to `app/router/keywords.py`
3. Create handler in `app/agent/handlers.py`
4. Add dispatch in `app/agent/chat_agent.py`
5. Update router in `app/router/router.py`

## ğŸ“Š Data Models

### SQLAlchemy Models

**Part**
- `part_id` (PK): PartSelect part number (e.g., PS11752778)
- `part_name`: Part name
- `part_price`: Price
- `description`: Part description
- `symptoms`: Common symptoms this part fixes
- `install_difficulty`: Installation difficulty
- `install_time`: Estimated install time
- `replace_parts`: Replacement part suggestions
- `appliance_type`: "refrigerator" or "dishwasher"
- `brand`: Brand name
- `product_url`: PartSelect product URL

**Model**
- `model_number` (PK): Appliance model number (e.g., WDT780SAEM1)
- `brand`: Brand name
- `appliance_type`: "refrigerator" or "dishwasher"
- `model_description`: Model description

**PartModelMapping**
- Links parts to compatible models
- `part_id` + `model_number` (unique constraint)

**Order**
- `id` (PK): Order ID
- `user_id`: User ID
- `part_id`: Part ID
- `status`: Order status
- `order_date`: Order date
- `shipping_type`: Shipping type

**Transaction**
- `id` (PK): Transaction ID
- `order_id`: Order ID (FK)
- `amount`: Transaction amount
- `status`: Payment status

## ğŸ§ª Testing

### Run Tests

```bash
# All tests
pytest

# Unit tests only
pytest tests/unit/

# Integration tests only
pytest tests/integration/

# With coverage
pytest --cov=app --cov-report=html

# Specific test file
pytest tests/unit/test_router.py
```

### Test API Endpoints

```bash
# Make sure server is running first
uvicorn app.main:app --reload

# Then run API test script
python test_api_queries.py
```

### Test Coverage

- **79 unit tests** covering:
  - Metadata extraction (27 tests)
  - Database queries (19 tests)
  - Router logic (14 tests)
  - Utility functions (19 tests)

- **Integration tests** covering:
  - Handler integration
  - End-to-end query flows

## ğŸ”§ Configuration

### Environment Variables

| Variable | Description | Default |
|----------|-------------|---------|
| `INSTALILY_DEEPSEEK_API_KEY` | DeepSeek API key | Required |
| `INSTALILY_LLM_PROVIDER` | LLM provider | `deepseek` |
| `INSTALILY_DEEPSEEK_MODEL` | DeepSeek model | `deepseek-chat` |
| `INSTALILY_OPENAI_API_KEY` | OpenAI API key (fallback) | Optional |
| `INSTALILY_OPENAI_MODEL` | OpenAI model | `gpt-4o-mini` |
| `INSTALILY_LOG_LEVEL` | Logging level | `INFO` |
| `INSTALILY_DATABASE_URL` | Database URL | `sqlite:///instalily.db` |
| `INSTALILY_CHROMA_DIR` | ChromaDB directory | `./chroma_db` |

### Constants

Key constants are centralized in:
- `app/config/constants.py`: LLM settings, RAG settings, error messages
- `app/config/prompts.py`: LLM prompts
- `app/config/urls.py`: PartSelect URLs

## ğŸš¢ Deployment

### Production Setup

1. **Set environment variables**
   ```bash
   export INSTALILY_DEEPSEEK_API_KEY=your_key
   export INSTALILY_LOG_LEVEL=WARNING
   ```

2. **Run data ingestion**
   ```bash
   python -m scripts.ingest_parts
   python -m scripts.ingest_docs
   ```

3. **Start server**
   ```bash
   uvicorn app.main:app --host 0.0.0.0 --port 8000
   ```

### Docker (Optional)

```dockerfile
FROM python:3.9-slim
WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt
COPY . .
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
```

## ğŸ“ˆ Performance

### Optimizations

- **Connection Pooling**: SQLAlchemy connection pooling
- **Retry Logic**: Exponential backoff for LLM calls
- **MMR Ranking**: Maximal Marginal Relevance for diverse RAG results
- **Caching**: LRU cache for LLM clients

### Monitoring

- Logging: Structured logging with configurable levels
- Health endpoint: `/health` for monitoring
- Error handling: Comprehensive error messages

## ğŸ” Troubleshooting

### Common Issues

**"DeepSeek API key missing"**
- Set `INSTALILY_DEEPSEEK_API_KEY` in `.env`

**"No module named 'chromadb'"**
- Run: `pip install chromadb`

**"Database not found"**
- Run: `python -m scripts.ingest_parts`

**"No RAG results"**
- Run: `python -m scripts.ingest_docs`